# 2. Создайте простейший в мире класс SimplePass. Затем создайте экземпляр класса и выведите на экран его тип.
print("Задание 2:")


class SimplePass(object):
    pass


test = SimplePass()
print(type(test))

# 3. Определите класс A, включающий:
# строку документирования класса '''Класс A''';
# метод set_a() для установки значения атрибута a;
# метод get_a() для получения значения этого атрибута.
# Выведите на экран документацию класса. Затем создайте первый экземпляр класса и при помощи определенных методов
# установите и выведите на экран значение его атрибута a. Далее создайте второй экземпляр класса, после чего также
# установите и выведите на экран значение атрибута a, но уже при помощи прямого доступа к атрибуту по точке.
print("\nЗадание 3:")


class A(object):
    """Класс А"""

    def set_a(self, a):
        self.a = a

    def get_a(self):
        return self.a


print(A.__doc__)

obj_A1 = A()
obj_A1.set_a("a1")
print(obj_A1.get_a())

obj_A2 = A()
obj_A2.a = "a2"
print(obj_A2.a)

# 4. Определите класс B, включающий:
# строку документирования класса '''Класс B''';
# конструктор, инициализирующий атрибут данных b создаваемых экземпляров;
# метод get_b() для получения значения этого атрибута. Выведите на экран документацию класса.
# Затем создайте экземпляр класса obj и при помощи метода экземпляра выведите на экран значение
# его атрибута b.
print("\nЗадание 4:")


class B(object):
    """Класс B"""

    def __init__(self, b):
        self.b = b

    def get_b(self):
        return self.b


print(B.__doc__)

obj_B3 = B("b3")
print(obj_B3.get_b())

# 5. Определите класс C, наследующий классы A (задача №3) и B (задача №4) и включающий:
# строку документирования класса '''Класс C = A + B''';
# -конструктор, инициализирующий дополнительно атрибуты данных a и c создаваемых экземпляров;
# -собственные методы set_b() и set_c() для установки значений соответствующих атрибутов;
# -собственный метод get_c() для получения значения атрибута c.
# Выведите на экран документацию класса. Затем создайте экземпляр класса obj, после чего при
# помощи соответствующих методов экземпляра выведите на экран значения его атрибутов a, b и c.
print("\nЗадание 5:")


class C(A, B):
    """Класс C = A + B"""

    def __init__(self, b):
        self.a = None
        self.c = None
        super().__init__(b)

    def set_b(self, b):
        self.b = b

    def set_c(self, c):
        self.c = c

    def get_c(self):
        return self.c


obj_C4 = C("cb")

obj_C4.set_a("ca")
obj_C4.set_c("cc")
print(obj_C4.get_a())
print(obj_C4.get_b())
print(obj_C4.get_c())

# 6. Определите класс D, включающий:
# статический метод stat_print_dict, выводящий на экран словарь атрибутов
# переданного ему объекта класса;
# метод класса cls_print_dict, выводящий на экран словарь атрибутов своего класса.
# Создайте экземпляр класса obj и, вызвав оба метода из этого экземпляра,
# выведите на экран словарь атрибутов класса D. Объясните различие в
# использовании методов.
print("\nЗадание 6:")


class D(object):
    @staticmethod
    def stat_print_dict(obj):
        print(obj.__dict__)
        pass

    @classmethod
    def cls_print_dict(cls):
        print(cls.__dict__)


obj = D
obj.stat_print_dict(obj)
print("\n")
obj.cls_print_dict()
print("\nРазличие в том, что один метод выводит словарь атрибутов любого принимаемого класса,"
      "а второй метод является выводит словарь атрибутов класса, которому он принадлежит")

# 7. Определите класс E, наследующий класс D (задача №6) и включающий
# единственный атрибут данных класса e = 'Класс E'. Создайте
# экземпляр obj_1 класса D и, вызвав оба метода из этого экземпляра,
# выведите на экран словарь атрибутов класса. Затем создайте
# экземпляр obj_2 класса E и также, вызвав оба метода из этого экземпляра,
# выведите на экран словарь атрибутов этого класса. Объясните результаты
print("\nЗадание 7:")


class E(D):
    e = 'Класс E'


obj_1 = D
obj_1.stat_print_dict(obj_1)
obj_1.cls_print_dict()

obj_2 = E
obj_2.stat_print_dict(obj_1)
obj_2.cls_print_dict()
print("\nМетод класса не учитывает наследованные атрибуты")

# 8. Определите класс F, наследующий класс A (задача №3), включающий:
# -конструктор, обновляющий строку документации создаваемых экземпляров
# на 'Объект класса F';
# -расширенный метод set_a() для установки значения атрибута a, который
# должен дополнительно выводить сообщение 'Атрибут a установлен!'.
# Выведите на экран документацию класса. Затем создайте экземпляр класса obj,
# после чего выведите его документацию и далее, при помощи соответствующих
# методов экземпляра, установите и выведите на экран значение его атрибута a.
# При расширении метода set_a() используйте по-очереди три варианта
# синтаксиса для доступа к методу суперкласса (незадействованные инструкции
# закомментируйте)
print("\nЗадание 8:")


class F(A):
    def __init__(self):
        self.__doc__ = """Объект класса F"""

    def set_a(self, a):
        super().set_a(a)
        # self.a = a
        # A(self).set_a(a)
        print("Атрибут A установлен!")


print(F.__doc__)

obj = F()
print(obj.__doc__)

obj.set_a("Изменение из экземпляра класса F")

print(obj.get_a())
import math

# 9. Определите класс Counter, реализующий десятичный счетчик, который может
# увеличивать или уменьшать свое значение на единицу в заданном диапазоне,
# включая границы диапазона. В классе должны быть предусмотрены
# следующие возможности:
# -конструктор для инициализации счетчика значениями по умолчанию
# (стартовое значение, нижняя и верхняя границы диапазона),
# -метод для его инициализации произвольными значениями,
# -а также методы для увеличения и уменьшения текущего значения счетчика.
# Все методы класса должны принимать только именованные параметры и
# проверять выход текущего значения счетчика за допустимый диапазон.
# Создайте экземпляр счетчика со значениями по умолчанию и выведите на экран
# его начальные параметры. Далее проверьте его работу циклом в пределах
# диапазона, увеличивая и выводя на экран его текущее значение от минимально
# возможного до максимального. Затем переустановите счетчик, задав
# отрицательную нижнюю и положительную верхнюю границы, а также установив
# положительное стартовое значение для отсчета. Опять же, проверьте его
# работу циклом, уменьшая и выводя на экран его текущее значение от
# стартового до минимально возможного. Задайте заведомо большее количество
# итераций циклов в обоих случаях, обеспечив прерывание их работы при
# попытке выхода счетчика за пределы диапазона.
print("\nЗадание 9:")


class Counter:
    def __init__(self):
        self.i = 1
        self.a = 1
        self.b = 10
        print("i= " + str(self.i) + "\na= " + str(self.a) + "\nb= " + str(self.b))

    def initialization(self, i, a, b):
        self.a = a
        self.b = b
        if a <= i <= b:
            self.i = i
        elif a > i:
            self.i = a
            print("Текущее значение счётчика установлено равным минимальной границе диапазона")
        else:
            self.i = b
            print("Текущее значение счётчика установлено равным максимальной границе диапазона")

    def inc(self):
        if self.b - self.i >= 1:
            self.i += 1
            print(self.i)
        else:
            print("Верхняя граница диапазона уже достигнута")

    def dec(self):
        if self.i - self.a >= 1:
            self.i -= 1
            print(self.i)
        else:
            print("Нижняя граница диапазона уже достигнута")

    def inf(self):
        print("Текущее значение счётчика: " + str(self.i))


test = Counter()
for i in range(15):
    test.inc()
    if test.b == test.i:
        break

for i in range(15):
    test.dec()
    if test.a == test.i:
        break

# 10. Определите класс Circle, представляющий окружность и включающий:
#  статический метод, переводящий метры в сантиметры или наоборот;
#  конструктор, инициализирующий радиус экземпляра;
#  методы получения длины и площади окружности.
# Используя созданный класс, расчитайте и выведите на экран длину и площадь
# окружности в сантиметрах зная, что ее радиус равен 2.55 метра.
print("\nЗадание 10:")


class Circle:

    def __init__(self, r):
        self.r = r

    @staticmethod
    def convert(length, str):
        if str == "cm_to_m":
            return length / 100
        if str == "m_to_cm":
            return length * 100
        else:
            print("Некорректный ввод")
            return 0

    def lenght(self):
        return 2 * math.pi * self.r

    def area(self):
        return math.pi * self.r * self.r


c1 = Circle(Circle.convert(2.55, "m_to_cm"))
print("Lenght is: " + str(c1.lenght()))
print("Area is: " + str(c1.area()))

# 11. Определите класс A, включающий метод plus() для сложения двух чисел, и
# класс B, включающий метод minus() для нахождения разности двух чисел.
# Оба метода должны инициализировать атрибуты last_res своих экземпляров
# списками формата [a, b, a op b] и возвращать результат арифметической
# операции. Затем определите класс C, содержащий конструктор для
# инициализации его атрибутов plus и minus соответствующими объектами
# методов первых двух классов. Далее создайте экземпляр класса obj, после
# чего найдите сумму и разность двух чисел, используя возможности
# созданного экземпляра.
print("\nЗадание 11:")


class A:
    @staticmethod
    def plus(a, b):
        last_res = [a, b, a + b]
        return a + b


class B:
    @staticmethod
    def minus(a, b):
        last_res = [a, b, a - b]
        return a - b


class C(A, B):

    def __init__(self, a, b):
        self.plus = A.plus(a, b)
        self.minus = B.minus(a, b)


obj = C(7, 2)
print("Разность: " + str(obj.minus))
print("Сумма: " + str(obj.plus))

# 12. Определите суперкласс Сотрудник, включающий:
#  конструктор, инициализирующий имя работника, его должность (по
# умолчанию None) и оклад (по умолчанию 0);
#  метод экземпляра для повышения оклада на какую-то часть (например, на 0.3,
# т.е. на 30%) с округлением результата до копеек;
#  магический метод __str__ для перегрузки строкового представления объекта,
# который должен выводить данные о работнике в формате 'Атрибут:
# объект.атрибут' по одной записи на каждой строке.
# Также определите подкласс Менеджер, наследующий суперкласс Сотрудник и
# переопределяющий метод повышения оклада таким образом, чтобы он еще
# больше повышал оклад за счет дополнительного бонуса в виде какой-то части
# оклада. Далее:
#  создайте экземпляр иван_менеджер созданного подкласса с начальным
# окладом в 1700 рублей;
#  повысьте сотруднику оклад за счет стандартной надбавки в 0.335 и бонуса за
# должность в 0.25;
#  выведите строковое представление объекта экземпляра с информацией о
# сотруднике на экран
print("\nЗадание 12:")


class Employee:
    def __init__(self, name, position="None", salary=0):
        self.name = name
        self.position = position
        self.salary = salary

    def increase(self, k):
        self.salary = round(self.salary * (1 + k), 2)

    def __str__(self):
        return (
                "Name: " + str(self.name) + "\n" +
                "Position: " + str(self.position) + "\n" +
                "Salary: " + str(self.salary) + "\n")


class Manager(Employee):
    def __init__(self, name, position, salary, b):
        super().__init__(name, position, salary)
        self.b=b

    def increase(self, k):
        self.salary = round(self.salary * (1 + k + self.b), 2)


ivanManager = Manager("Иван", "Менеджер", 1700, 0.25)
ivanManager.increase(0.335)
print(ivanManager.__str__())
